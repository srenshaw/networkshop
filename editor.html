<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Ego-Centric Network Editor</title>
  <style>
    /* Overall styling */
    body {
      font-family: Arial, sans-serif;
      background: #f2f2f2;
      margin: 0;
      padding: 0;
    }
    #container {
      display: flex;
      flex-wrap: wrap;
      margin: 20px;
    }
    #editor, #visualizer {
      background: #fff;
      border-radius: 8px;
      padding: 20px;
      margin: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    #editor {
      flex: 1;
      min-width: 300px;
    }
    #visualizer {
      flex: 2;
      min-width: 400px;
      position: relative;
    }
    /* Mode options styling */
    #modeOptions {
      margin-bottom: 10px;
    }
    #modeOptions label {
      margin-right: 15px;
    }
    /* Table/grid styling */
    table {
      border-collapse: collapse;
      margin-bottom: 10px;
      width: 100%;
    }
    table, th, td {
      border: 1px solid #ccc;
    }
    th, td {
      width: 60px;
      height: 35px;
      text-align: center;
    }
    input[type="text"] {
      width: 100%;
      border: none;
      padding: 5px;
      box-sizing: border-box;
    }
    input[type="text"]:focus {
      outline: none;
      background-color: #e6f7ff;
    }
    button {
      padding: 8px 12px;
      margin: 5px 0;
      background-color: #1f77b4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background-color: #155d8b;
    }
    /* Node edit controls */
    #nodeControls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    #nodeControls input[type="color"],
    #nodeControls input[type="range"] {
      margin-left: 5px;
    }
  </style>
  <!-- Load D3.js for network visualization -->
  <script src="https://d3js.org/d3.v6.min.js"></script>
</head>
<body>
  <div id="container">
    <!-- Grid Editor -->
    <div id="editor">
      <h2>Network Grid Editor</h2>
      <!-- Mode Options: Simplex (symmetric) and Directional -->
      <div id="modeOptions">
        <label><input type="checkbox" id="simplexMode"> Simplex Mode (symmetric ties)</label>
        <label><input type="checkbox" id="directionalMode"> Directional Links (arrows)</label>
      </div>
      <button id="addRowCol">Add Node</button>
      <table id="grid"></table>
      <button id="submitGrid">Submit & Visualize</button>
      <button id="exportCSV">Export CSV</button>
    </div>
    <!-- Network Visualizer -->
    <div id="visualizer">
      <h2>Network Visualizer</h2>
      <svg id="networkSvg" width="600" height="600"></svg>
      <!-- Node editing controls (appear when a node is clicked) -->
      <div id="nodeControls" style="display:none;">
         <h3>Edit Node</h3>
         <label for="nodeColor">Color:</label>
         <input type="color" id="nodeColor" value="#1f77b4">
         <br>
         <label for="nodeSize">Size:</label>
         <input type="range" id="nodeSize" min="5" max="50" value="15">
         <br>
         <button id="updateNode">Update Node</button>
      </div>
    </div>
  </div>

  <script>
    /* Global variables */
    let gridSize = 3; // starting with 3 nodes
    let selectedNode = null;
    // Save node-specific properties so that custom colors and sizes persist.
    let nodeProperties = {}; // e.g., { 0: {color: "#ff0000", size: 20}, ... }

    // Initialize the grid and event listeners when the page loads.
    document.addEventListener('DOMContentLoaded', function() {
      generateGrid(gridSize);
      document.getElementById('addRowCol').addEventListener('click', addNode);
      document.getElementById('submitGrid').addEventListener('click', submitGrid);
      document.getElementById('exportCSV').addEventListener('click', exportCSV);
      document.getElementById('updateNode').addEventListener('click', function(){
         if (selectedNode) {
            let newColor = document.getElementById('nodeColor').value;
            let newSize = +document.getElementById('nodeSize').value;
            nodeProperties[selectedNode.id] = { color: newColor, size: newSize };
            updateVisualization();
            document.getElementById('nodeControls').style.display = 'none';
         }
      });
      // Render the initial (empty) visualization.
      updateVisualization();
    });

    // Build the grid table with a header row and column.
    function generateGrid(n) {
      gridSize = n;
      let table = document.getElementById('grid');
      table.innerHTML = '';

      // Create header row (first row): the first cell is empty.
      let headerRow = document.createElement('tr');
      let corner = document.createElement('th');
      headerRow.appendChild(corner);
      for (let j = 0; j < n; j++) {
          let th = document.createElement('th');
          let input = document.createElement('input');
          input.type = 'text';
          input.placeholder = 'Name';
          input.className = 'node-name';
          input.setAttribute('data-index', j);
          input.addEventListener('input', syncHeaders);
          th.appendChild(input);
          headerRow.appendChild(th);
      }
      table.appendChild(headerRow);

      // Create a row for each node.
      for (let i = 0; i < n; i++) {
          let row = document.createElement('tr');
          // Left header cell with node name.
          let th = document.createElement('th');
          let input = document.createElement('input');
          input.type = 'text';
          input.placeholder = 'Name';
          input.className = 'node-name';
          input.setAttribute('data-index', i);
          input.addEventListener('input', syncHeaders);
          th.appendChild(input);
          row.appendChild(th);
          // Create relationship cells.
          for (let j = 0; j < n; j++) {
              let td = document.createElement('td');
              let cellInput = document.createElement('input');
              cellInput.type = 'text';
              cellInput.className = 'cell-input';
              cellInput.setAttribute('data-row', i);
              cellInput.setAttribute('data-col', j);
              // Diagonal cells are disabled; all others start with "0"
              if (i === j) {
                  cellInput.value = "0";
                  cellInput.disabled = true;
              } else {
                  cellInput.value = "0";
              }
              cellInput.addEventListener('input', handleCellInput);
              td.appendChild(cellInput);
              row.appendChild(td);
          }
          table.appendChild(row);
      }
    }

    // Keep header inputs synchronized (top row and left column for each node).
    function syncHeaders() {
      let index = this.getAttribute('data-index');
      let inputs = document.querySelectorAll('.node-name[data-index="' + index + '"]');
      inputs.forEach(input => {
         if (input !== this) {
             input.value = this.value;
         }
      });
      updateVisualization();
    }

    // Handle cell input, enforcing values of "0" or "1" and applying simplex mode if enabled.
    function handleCellInput(e) {
      let cellValue = e.target.value.trim();
      // Only allow "1" for a tie; otherwise, default to "0".
      if (cellValue !== "1") {
          cellValue = "0";
          e.target.value = "0";
      }
      // If simplex mode is enabled, update the symmetric cell.
      if (document.getElementById("simplexMode").checked) {
          let row = e.target.getAttribute("data-row");
          let col = e.target.getAttribute("data-col");
          let symmetricCell = document.querySelector(`.cell-input[data-row="${col}"][data-col="${row}"]`);
          if (symmetricCell && symmetricCell.value.trim() !== cellValue) {
              symmetricCell.value = cellValue;
          }
      }
      updateVisualization();
    }

    // Add a new node by appending a new row and column to the grid.
    function addNode() {
      gridSize++;
      let table = document.getElementById('grid');

      // Append a new header cell (for the new column) in the first row.
      let headerRow = table.rows[0];
      let newTh = document.createElement('th');
      let newInput = document.createElement('input');
      newInput.type = 'text';
      newInput.placeholder = 'Name';
      newInput.className = 'node-name';
      newInput.setAttribute('data-index', gridSize - 1);
      newInput.addEventListener('input', syncHeaders);
      newTh.appendChild(newInput);
      headerRow.appendChild(newTh);

      // Create a new row for the new node.
      let newRow = document.createElement('tr');
      let newRowHeader = document.createElement('th');
      let newRowInput = document.createElement('input');
      newRowInput.type = 'text';
      newRowInput.placeholder = 'Name';
      newRowInput.className = 'node-name';
      newRowInput.setAttribute('data-index', gridSize - 1);
      newRowInput.addEventListener('input', syncHeaders);
      newRowHeader.appendChild(newRowInput);
      newRow.appendChild(newRowHeader);

      // Create relationship cells for the new row.
      for (let j = 0; j < gridSize; j++) {
          let td = document.createElement('td');
          let cellInput = document.createElement('input');
          cellInput.type = 'text';
          cellInput.className = 'cell-input';
          cellInput.setAttribute('data-row', gridSize - 1);
          cellInput.setAttribute('data-col', j);
          if ((gridSize - 1) === j) {
              cellInput.value = "0";
              cellInput.disabled = true;
          } else {
              cellInput.value = "0";
          }
          cellInput.addEventListener('input', handleCellInput);
          td.appendChild(cellInput);
          newRow.appendChild(td);
      }
      table.appendChild(newRow);

      // For every existing row (except the header row), add a new cell for the new column.
      for (let i = 1; i < table.rows.length - 1; i++) {
          let row = table.rows[i];
          let td = document.createElement('td');
          let cellInput = document.createElement('input');
          cellInput.type = 'text';
          cellInput.className = 'cell-input';
          cellInput.setAttribute('data-row', i - 1);
          cellInput.setAttribute('data-col', gridSize - 1);
          if ((i - 1) === (gridSize - 1)) {
              cellInput.value = "0";
              cellInput.disabled = true;
          } else {
              cellInput.value = "0";
          }
          cellInput.addEventListener('input', handleCellInput);
          td.appendChild(cellInput);
          row.appendChild(td);
      }
      updateVisualization();
    }

    // On "Submit & Visualize", ensure all cells are "0" or "1" and update the visualization.
    function submitGrid() {
      let cellInputs = document.querySelectorAll('.cell-input');
      cellInputs.forEach(input => {
         if (input.value.trim() !== "1") {
              input.value = "0";
         }
      });
      updateVisualization();
    }

    // Read the grid and header values, build nodes and links arrays, then render the network.
    function updateVisualization() {
      let nodes = [];
      let headerInputs = document.querySelectorAll('tr:first-child .node-name');
      headerInputs.forEach((input, i) => {
         let name = input.value.trim() || "Node " + (i + 1);
         let defaultColor = "#1f77b4";
         let defaultSize = 15;
         if (nodeProperties[i]) {
            defaultColor = nodeProperties[i].color;
            defaultSize = nodeProperties[i].size;
         }
         nodes.push({ id: i, name: name, color: defaultColor, size: defaultSize });
      });

      let links = [];
      let cellInputs = document.querySelectorAll('.cell-input');
      cellInputs.forEach(input => {
         let value = input.value.trim();
         let row = parseInt(input.getAttribute('data-row'));
         let col = parseInt(input.getAttribute('data-col'));
         if (row !== col && value === "1") {
              links.push({ source: row, target: col });
         }
      });

      drawNetwork(nodes, links);
    }

    // Render the network using D3's force-directed layout.
    function drawNetwork(nodes, links) {
      const svg = d3.select("#networkSvg");
      const width = +svg.attr("width");
      const height = +svg.attr("height");
      svg.selectAll("*").remove();

      // If directional mode is enabled, add arrow marker definitions.
      if (document.getElementById("directionalMode").checked) {
          var defs = svg.append("defs");
          defs.append("marker")
              .attr("id", "arrow")
              .attr("viewBox", "0 -5 10 10")
              .attr("refX", 15)
              .attr("refY", 0)
              .attr("markerWidth", 6)
              .attr("markerHeight", 6)
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M0,-5L10,0L0,5")
              .attr("fill", "#999");
      }

      const simulation = d3.forceSimulation(nodes)
          .force("link", d3.forceLink(links).id(d => d.id).distance(100))
          .force("charge", d3.forceManyBody().strength(-300))
          .force("center", d3.forceCenter(width / 2, height / 2));

      // Draw links.
      const link = svg.append("g")
          .attr("class", "links")
          .selectAll("line")
          .data(links)
          .enter().append("line")
          .attr("stroke", "#999")
          .attr("stroke-width", 2)
          .attr("marker-end", function(d) {
              return document.getElementById("directionalMode").checked ? "url(#arrow)" : null;
          });

      // Draw nodes.
      const node = svg.append("g")
          .attr("class", "nodes")
          .selectAll("circle")
          .data(nodes)
          .enter().append("circle")
          .attr("r", d => d.size)
          .attr("fill", d => d.color)
          .call(d3.drag()
              .on("start", dragstarted)
              .on("drag", dragged)
              .on("end", dragended))
          .on("click", nodeClicked);

      // Add labels.
      const label = svg.append("g")
          .attr("class", "labels")
          .selectAll("text")
          .data(nodes)
          .enter().append("text")
          .attr("dy", -10)
          .attr("text-anchor", "middle")
          .text(d => d.name)
          .attr("font-size", "12px")
          .attr("fill", "#333");

      simulation.on("tick", () => {
          link.attr("x1", d => d.source.x)
              .attr("y1", d => d.source.y)
              .attr("x2", d => d.target.x)
              .attr("y2", d => d.target.y);

          node.attr("cx", d => d.x)
              .attr("cy", d => d.y);

          label.attr("x", d => d.x)
               .attr("y", d => d.y);
      });

      function dragstarted(event, d) {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
      }
      function dragged(event, d) {
          d.fx = event.x;
          d.fy = event.y;
      }
      function dragended(event, d) {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;
      }
      function nodeClicked(event, d) {
          selectedNode = d;
          let controls = document.getElementById('nodeControls');
          controls.style.display = 'block';
          document.getElementById('nodeColor').value = d.color;
          document.getElementById('nodeSize').value = d.size;
      }
    }

    // Export the current grid as a CSV file.
    function exportCSV() {
      let csv = "";
      let table = document.getElementById("grid");
      for (let i = 0; i < table.rows.length; i++) {
        let row = table.rows[i];
        let rowData = [];
        for (let j = 0; j < row.cells.length; j++) {
          let cell = row.cells[j];
          let input = cell.querySelector("input");
          if (input) {
            rowData.push('"' + input.value.trim() + '"');
          } else {
            rowData.push('""');
          }
        }
        csv += rowData.join(",") + "\n";
      }
      let blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      let url = URL.createObjectURL(blob);
      let a = document.createElement("a");
      a.href = url;
      a.download = "ego_network.csv";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }
  </script>
</body>
</html>
